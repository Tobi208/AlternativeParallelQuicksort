Used comp opts (as recommended per lecture): -O3 -march=native -ffast-math


Expectations for loop_invariants FAST vs SLOW:

FAST is probably much faster because it computes iN and tmp less often which especially reduces / operations. It's a simple loop, so the compiler can probably optimize it easily, I don't think there will be much of a difference with comp opts.

SLOW, no  comp opts, fasted user time out of 5: 2,185s
SLOW, all comp opts, fasted user time out of 5: 0,228s

FAST, no  comp opts, fasted user time out of 5: 1,691s
FAST, all comp opts, fasted user time out of 5: 0,224s

The measurements match my expectations.



Expectations for string_loop FAST vs SLOW:

FAST should definitely be much faster with comp opts, because the loop is countable as opposed to the SLOW uncountable while loop. Assuming that gcc doesn't optimize this without the appropriate flags, I don't exepect a big difference without comp opts.

SLOW, no  comp opts, fasted user time out of 5: 3,434s
SLOW, all comp opts, fasted user time out of 5: 0,852s

FAST, no  comp opts, fasted user time out of 5: 3,646s
FAST, all comp opts, fasted user time out of 5: 0,052s

The measurements match my expectations.



Expectations for array_loop FAST vs SLOW:

I think FAST is going to be faster unoptimized because shifting the pointer is faster than accessing the i-th element as in SLOW but I think the optimized SLOW is going to be faster than optimized FAST because the loop is countable - same as for string_loop.

SLOW, no  comp opts, fasted user time out of 5: 3,277s
SLOW, all comp opts, fasted user time out of 5: 0,000s

FAST, no  comp opts, fasted user time out of 5: 2,927s
FAST, all comp opts, fasted user time out of 5: 0,000s

The measurements match my expectations for unoptimized compilations but I suppose the compiler was smart enough to also turbo optimize the pointer shifting in an uncountable loop?
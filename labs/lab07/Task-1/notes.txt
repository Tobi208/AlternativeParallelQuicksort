N = 200, -O2, factor 4
f_std tests took   1.329 wall seconds.
f_opt tests took   0.802 wall seconds.

Yes, the opted version is faster. A good choice for a factor is something that yields speedup but maintains correctness and readability. I imagine it should fill one or more full cachelines per iteration. Assuming 64 B per cacheline, it should load 8 doubles per buffer per iteration. However, factor 4 and 8 didn't make a difference when I tested it.

The loop condition had to be adjusted a bit for non-divisible factors.


N = 200, -funroll-loops, factor 4
f_std tests took   0.830 wall seconds.
f_opt tests took   0.799 wall seconds.

The flag seems to make the compiler unroll the loop in a similar way.


N = 200, -O3, factor 4
f_std tests took   1.330 wall seconds.
f_opt tests took   0.795 wall seconds.

The -O3 flag did not appear to unroll the loop better than the optimization.


N = 200, -O3 -funroll-loops, factor 4
f_std tests took   0.417 wall seconds.
f_opt tests took   0.400 wall seconds.

Fasted compiler optimization.


The gcc man page on vitsippa states "This option makes code larger, and may or may not make it run faster."
Seems fair enough.
tola9583@vitsippa:~/hpp/labs/lab5/Task-3$ ./float

 --- large float ---
99999996802856924650656260769173209088.000000

 --- small float ---
-99999996802856924650656260769173209088.000000

 --- large double ---
19892929456391470604942371664378261518320584467342079688519749420783554837598095354381919709304069136273155701450708464806401458862031614110592643009264483184858370349410041378463858669590115348739546748786831484041619762305048038610964548055688980941072499918006546589449328858374887316125931917718308519936.000000

 --- small double ---
-19892929456391470604942371664378261518320584467342079688519749420783554837598095354381919709304069136273155701450708464806401458862031614110592643009264483184858370349410041378463858669590115348739546748786831484041619762305048038610964548055688980941072499918006546589449328858374887316125931917718308519936.000000

 --- not a number ---
-nan

 --- continued use of NaN and INF ---
Nan: -nan
Inf: inf

Based on the math in the instructions I expected a value slightly lower than 23 * 2^128 for floats, and 52 * 2^1024 which seems to approximately match.
Continued operations on NaN and INF just cause more NaN and INF which seems to makes sense.



For the precision experiment I get the result:

last viable epsilon: 2^-24

which correlates to the Mantissa maybe, but I'm not sure of the math behind it.



Experiments for denormalized floating points numbers (best of 5):

          no opt     -O2     -O3  -Ofast
denorms   0,308s  0,166s  0,166s  0,097s
norms     0,311s  0,166s  0,162s  0,097s

                no opt          -O2          -O3       -Ofast
denorms   1.000000e-39 1.000000e-39 1.000000e-39 1.000000e-39
          9.999960e-40 9.999960e-40 9.999960e-40 0.000000e+00

I compiled and took the measurements on vitsippa and the performance doesn't seem to change.
As expected, the subnormal floating point number is rounded to 0 with the -Ofast opt.

After changing tiny to 1e-50:

          no opt     -O2     -O3  -Ofast
denorms   0,311s  0,001s  0,001s  0,001s

all output becomes
0.000000e+00
0.000000e+00

I suppose the number simply gets treated as 0? Especially in the optimized compilations.